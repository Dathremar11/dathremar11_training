"""
Сортировка Тони Хоара
"""

"""
Для выбора барьерного эелемента используются генераторы случайных чисел (?)
В примере ниже, возьмем в качестве барьерного - первый элемент массива
C дополнительной паметью *
"""

def hoar_sort(A):  # 
    if len(A) <= 1: # Выбираем крайний случай рекурентной ф-ии
    """ Функция сортирует сам A[] по ссылке
    принимает изменяемый список, который по этой ссылке
    можно будет менять и ожидается что она его отсортирует
    """
        return     # тоже самое что return None - None type специальное, единственное допустимое значение - ничего, Имя = ничему. Тем самым Имя отвязывается от объекта к которому было приявязано и сборщик мусора объект съедает - имя остается
    
    barrier = A[0] #выбор барьерного элемента
    L = []
    R = []
    M = []
    
    for x in A:        # Разделить массив на 3 раздела относительно барьерного элемента. 3 раздела массива - динамические
        if x < barrier:
            L.append(x)
        elif x == barrier:
            M.append(x)
        else:
            R.append(x)

hoar_sort(L)        # Сортировать средний элемент не нужно, т.к. там все элементы равны
hoar_sort(R)

    k = 0 # Увроень заполненности A[]
    for x in L+M+R:  # Скленый массив
        A[k] = x     # Кладем значение в массив A[]
        k += 1