/* Аргументы в функцию передаются по значению, т.е
 * при вызове функции для хранения фактических переданных значений
 * создаются временные переменные - ячейки памяти на сегменте STACK.
 *После выхода функции эти переменные уничтожаются.
*/
#include <iostream>

void increment(int a)   // При вызове появляется переменная а с копией значения b.
{   // В каждый вызов функции будет создаваться новый экземпляр ячейки a, который будет иметь то же имя а, но будет являться другой       являться другой ячейкой
    std::cout << a '\n';
    a = a + 1;          // Значение увеличивается на 1.
    std::cout << a << '\n';
                        // Однако, при выходе из функции переменная а уничтожается.
}

int main()
{
    using namespace std;
    int b = 3;

    increment(b);       // Здесь число 3 будет скопировано из b во временную а.
    cout << b << endl;  // Естественно, вызов функции inc(b) не изменил b.

    return 0;
}

// Вывод: 3; 4; 4.
/*
 -ОЗУ-
********   // Компилятор, когда работает с переменной b - каждый раз 
* a-1  *   // пользуется ячейкой в памяти компьютера
*      *   
********
* 3    *   <-- b         
*      *    
********
* a+1  *
*      * 
********                     
*      *   
*      *   <-- a // В а скопировалось значение 3 из ячейки памяти b, значение a изменилось a = a + 1; после чего функция
********         // закончила выполнение и переменная уничтожилась, т.к. она находиться в ОДЗ функции void uncrement()
*      *  
*      *         // Адреса нельзя складывать и умножать а1 + а2; // Можно a + x; a - x; a1 - a2 - должны быть одного и того же типа -
********         // результат вычитания адресов - число
*      *
*      *
********
*/

/*----------------------------------------------------------------------------------------------------------------------*/
/* Поскольку аргументы функции передаются по значению, то мы должны передать в функцию не самы переменную, а ее адрес*/

#include <iostream>

void increment(int* a)  // При вызове появиться переменная а с адресом b. // int *a, * - часть типа
{
    *а = *а + 1;        // Значение по адресу а увеличивается на 1.
                        // Однако, при выходе из функции указатель а уничтожается.
}                       // * - пройти по адресу
                        // *a = *a + 1; + 1 - означает сдвинуться не на 1 байт, а сдвиг на размер ячейки b см. ниже 
int main()
{
    using namespace std;
    int b = 3;

    increment(&b);      // Здесь будет скопирован адрес переменной b.
    cout << b << endl;  // Естественно, вызов функции inc(b) не изменил b.

    return 0;
}
// Вывод: b - выросла на 1: 4

// z = x&y;  // Все целыйе числа, и оператор & - битовая коньюнкция "И". Бинарный оператор, т.к. у него два операнда.
// &X; - Взятие адреса. Унарный оператор, т.к. у него один операнд.
/*

 -ОЗУ-
********   // Компилятор, когда работает с переменной b - каждый раз 
*      *   // пользуется ячейкой в памяти компьютера
*      *   
********
*Ячейка*    <-- b  (3)        // Компилятор обрабатывает ИМЯ ПЕРЕМЕННОЙ - как ее значение (хотя на самом деле пользуется адресом b)
*Памяти*    <-- &b - адрес b  // Способ спросить компилятор, где храниться значение b. Взятие адреса - возврат 1-го байта ячейки
********                      // Адрес - это число (минимум 32-х битные)
*      *   // Для Архитектурно-ориентированных языков, таких как С и С++ есть возможность узнать адрес ячейки памяти в ОЗУ
*      *   // *Имя переменно файтически и есть ее адрес, компилятор подставляет его каждый раз, когда хочет ей воспользоваться
********
* "a"  *   // <-- &b - Сам адрес нужно полужить в ячейку памяти, которая должен быть того же типа, что и b
*      *   // ячейка а будет ссылаться на ячейку b
********    
*      *
*      *
********
Тип &b - int*; // * - Спецсимвол, а не операция, адресный тип (любой адресный тип содержит *, как минимум одну)
*/