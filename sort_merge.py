""" Алгоритм слиянием """
def  merge(A:list, B:list):  
    C = [0] * (len(A) + len(B))
    i = k = n = 0           # i - индекекс A[]; k - индекс B[]; n - индекс C[]
    """ Разбиваем на два масива и сравниваем индексы: """
    while i < len(A) and k < len(B):
        if  A[i] <= B[k]:   # Выбираем наименьшее число в одинаковом индексе массивов
            C[n] = A[i]     # А[0] < B[0] = положить в С[0] значение А[0], наименьшего
            i += 1          # Сдвинутся на А[1], где 1 - индекс массива
            n += 1          # Сдвинуться в С[0, 1], на +1, т.к. C[0] уже заполнен
        else:
            C[n] = B[k]
            k += 1
            n += 1
    """ Когда один из индексов i или k - вышли за границу массива
        предыдущий цикл остановиться недойдя до конечного элемента массива
        оставшегося наибольшего элемента
    """
    while i < len(A):
        C[n] = A[i]
        i += 1
        n += 1
    while k < len(B):
        C[n] = B[k]
        k += 1
        n += 1
    return C
#print(*B) развернуть список в параметры функции
""" Рекурентная функция сортировки (для слияния)"""
def merg_sort(A):
    if len(A) <= 1:           # Проверяем крайний случай рекурсии
        return                # Сортирует сам масиив А, а не возвращает отсортированный масиив
    middle = len(A) // 2      # Отмеряем левую и правую половину / разбивка основного масиива
    L = [A[i] for i in range(0, middle)]   # Создали левую половину / Можно сделать срезом списка 
    R = [A[i] for i in range(middle, len(A))]
    merge_sort(L)
    """
def merg_sort(L):
    if len(L) <= 1:           # Проверяем крайний случай рекурсии
        return                # Сортирует сам масиив А, а не возвращает отсортированный масиив
    middle = len(A) // 2      # Отмеряем левую и правую половину / разбивка основного масиива
    L = [L[i] for i in range(0, middle)]   # Создали левую половину / Можно сделать срезом списка 
    R = [L[i] for i in range(middle, len(A))]
    merge_sort(L)
    """
    merg_sort(R)    # L и R сами в себе отсортированы
    C = merge(L, R) # Сливаем два массива в третий
    for i in range(len(A)):     # Можно сделать срезом
        A[i] = C[i]


"""
Сортировка называется устойчивой, если она не меняет
порядок равных элементов
"""

