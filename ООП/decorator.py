"""
- Декаратор - это специальная функция, которая изменяет поведение функции или класса. Для применения декоратора следует перед соответствующим
обхявлением указать символ @, имя необходимого декоратора и список его аргументов в круглых скобках. Если передача параметров декоратору
не требуется, скобки () не указываются.
- Для создания статических методов используется декоратор staticmethod.
- Для создания методов лкасса используется декоратор classmethod.

"""
class MyObject:
    class_attribute = 8                  # Атрибут класса

    def __init__(self):                  # Метод конструктор
        self.data_attribute = 42         # Создает атрибут данных

    def instance_method(self):           # Метод (обычный метод экземпляра)
        print(self.data_attribute)       # Возвращает атрибут данных data_attribute объекта экземпляра self

    @staticmethod                        # Статический метод, который будет работать на самом классе и всех его экземплярах
    def static_method():                 # Объявление статического метода // У него нету первого параметра self, который отвечает за передачу ссылки на соответствующие экземпляры.
        print(MyObject.class_attribute)  # Потому что данный метод не привязан к эземпляру объекта, может быть вызван на самом класса
                                         # Не имеет доступ к атрибутам данных, их не от куда получать
if __name__ = "__main__":                # Если наш модуль будет запущен как исполняемый файл
    MyObject.static_method()             # то вызовем статический метод на классе
    obj = MyObject()                     # Создадим экзепляр данного класса
    obj.instance_method()                # Вызовем его метод экземпляра класса
    obj.static_method()        # И вызовем статический метод

    """
    Можно написать функцию класса с атрибутом def static_method(): - не принимает никакие параметры, без @staticmethod и можно
    будет вызвать ее на классе. Но как только мы попытаемся вызвать ее на экземпляре класса - мы получим ошибку, т.к. python
    пытается передать туда в качестве первого аргумента ссылку на тот объект на которым мы вызваем данный метод.
    static_method(): - принимает 0 позиционных аргументов, а ей передают 1, возникает ошибка 
    
    Если используем @staticmethod, то он никуда привязан не будет, поэтому его можно будет вызывать как на классе, так и на его
    экземпляров. (нужен если понадобиться создать атрибут класса, который является функцией, но не привязан к конкретному экземпляру)
    """