https://tokmakov.msk.ru/blog/item/473?ysclid=m1dolutgxo530938626

https://manpages.ubuntu.com/manpages/xenial/man8/iptables-extensions.8.html

Утилита iptables
Синтаксис утилиты iptables:

$ sudo iptables [-t таблица] команда [критерий действие]Копировать
Если таблица не указана, подразумевается таблица filter. Команды могут быть:

-A (или --append) — добавить правило в цепочку
-D (или --delete) — удалить правило из цепочки
-I (или --insert) — вставить правило в цепочку под указанным номером
-L (или --list) — вывести все правила для заданной цепочки
-F (или --flush) — очистить все правила для заданной цепочки (таблицы)
-N (или --new-chain) — создать новую цепочку
-X (или --delete-chain) — удалить цепочку
-P (или --policy) — установить действие по умолчанию для цепочк

Имеются следующие дополнительные опции:

-v (или --verbose) — увеличить подробность сообщений, при указании с командой --list будет выводиться имя интерфейса, параметры правил и маски TOS.
-n (или --numeric) — выводить ip-адреса и номера портов в числовом виде, предотвращая попытки преобразовать их в символические имена.
--line-numbers — показывать номера строк при отображении списка правил командой --list (номер строки соответствует позиции правила в цепочке).

Если верить man странице, то одно делает OR, а другая XOR. Маску можно указывать и для --set-mark и для --set-xmark.
И то и другое и маска имеет смысл при сложной маркировке пакетов, когда пакет сначала маркируется одним значением, а потом уточняется другим. За счёт маски можно в одном правиле выставить старшие разряды маркера, а в другом правиле выставить младшие разряды.

Уточнение происходит примерно так:

newmark = (ct->mark & ~info->ctmask) ^ info->ctmark;
if (ct->mark != newmark) {
    ct->mark = newmark;
    nf_conntrack_event_cache(IPCT_MARK, ct);
}
где ctmark — маркировка, ctmask — маска.
Единственное отличие mark от xmark — в случае с mark при установке 
значения ctmask оно ORится с ctmark, что в конечном счете обеспечивает 
установку заново для всех ненулевых битов ct->mark (а не XOR со старыми).

Еще пример:
4 OR 2 = 6
4 OR 4 = 4

iptables -t mangle -A -s 10.1.1.0/24 -j MARK --set-mark 0x100
...
iptables -t mangle -A -p icmp -j MARK --set-mark 0x01/0xff
iptables -t mangle -A -p tcp --syn -j MARK --set-mark 0x02/0xff


Создание пользовательских цепочек
Iptables позволяет создавать пользовательские цепочки для более гибкого управления правилами. 
Например, вы можете создать цепочку для обработки всего трафика от определенного IP-адреса:

iptables -N MY_CHAIN 
iptables -A MY_CHAIN -s 192.168.0.100 -j DROP 
iptables -A INPUT -j MY_CHAIN 


В этом примере команда -N MY_CHAIN создает новую цепочку с именем MY_CHAIN. 
Затем добавляется правило, которое отбрасывает все пакеты от 192.168.0.100. 
Наконец, цепочка MY_CHAIN добавляется в цепочку INPUT, что означает, 
что все входящие пакеты будут также проходить через цепочку MY_CHAIN.


iptables -t mangle -A FORWARD -p tcp --dport 443 -m connbytes --connbytes-dir original --connbytes-mode packets --connbytes 0:19 -j NFQUEUE --queue-num 537 --queue-bypass

connbytes позволяет отбирать пакеты по количеству данных, переданных по настоящий момент, или по среднему размеру пакета. 

--connbytes-dir указывает, какие пакеты учитывать (свои, ответные или все). 

--connbytes-mode определяет отслеживаемый показатель — число пакетов, байтов или средний размер всех полученных пакетов (в байтах). 

iptables -t mangle -I POSTROUTING -o <external_interface> -p tcp --dport 80 -m connbytes --connbytes-dir=original --connbytes-mode=packets --connbytes 1:6 -m mark ! --mark 0x40000000/0x40000000 -m set --match-set zapret dst -j NFQUEUE --queue-num 200 --queue-bypass

Эта команда позволяет снизить нагрузку на процессор, отказываясь обрабатывать ненужные пакеты.